import execa from 'execa'
import path from 'path'
import { getPackages } from '@manypkg/get-packages'
import findUp from 'find-up'
import axios from 'axios'
import type { CiCdCommandArguments, CiCdContext } from './types'
import { deployAllBackendPackagesToK8s } from './deploy-packages-to-k8s'
import { deployAllUiPackagesToSurge } from './deploy-all-ui-packages-to-surge'
import { hashElement } from 'folder-hash'
import omit from 'lodash/omit'

export async function getBranchName({
  repoPath,
  env,
}: {
  repoPath: string
  env: Omit<NodeJS.ProcessEnv, 'NODE_ENV'>
}): Promise<string> {
  // in aws-code-build, `git branch --show-current` returns nothing :S
  if (env.GITHUB_REF_NAME === 'main') {
    return 'main'
  }
  const branch = env.CODEBUILD_WEBHOOK_TRIGGER?.replace('branch/', '')
  if (branch) {
    return branch
  }
  return execa
    .command('git branch --show-current', {
      stdio: 'pipe',
      cwd: repoPath,
    })
    .then(r => r.stdout)
}

export async function getCiCdContext({
  env,
  ciCdCommandArguments,
}: {
  env: Omit<NodeJS.ProcessEnv, 'NODE_ENV'>
  ciCdCommandArguments: CiCdCommandArguments
}): Promise<CiCdContext> {
  const repoPath = path.dirname((await findUp('yarn.lock', { cwd: __dirname }))!)

  const { hash: repoChecksum, children: c1 } = await hashElement(repoPath, {
    folders: { exclude: ['node_modules', 'dist', 'cache', 'artifacts', '.git'], matchBasename: true },
    encoding: 'hex',
  })

  const isRunningInGithubActions = Boolean(env.GITHUB_REF_NAME)

  const isMainBuild = env.GITHUB_REF_NAME === 'main'
  const isPrBuild = !isMainBuild

  const [packages, gitHeadSha, gitBranchName] = await Promise.all([
    getPackages(repoPath),
    execa
      .command(`git log -1 --pretty=%H`, {
        stdio: 'pipe',
        cwd: repoPath,
      })
      .then(r => r.stdout),
    getBranchName({ repoPath, env }),
  ])

  const formattedGitBranchName = gitBranchName.replace('/', '_')

  const runOnlyOnPackageNames = packages.packages
    .map(p => p.packageJson.name)
    .filter(
      name =>
        ciCdCommandArguments.packages === 'all' ||
        ciCdCommandArguments.packages
          .split(',')
          .map(p => p.trim())
          .includes(name),
    )

  return {
    repoPath,
    repoChecksum,
    packages,
    gitHeadSha,
    gitBranchName,
    formattedGitBranchName,
    isRunningInGithubActions,
    isMainBuild,
    isPrBuild,
    runOnlyOnPackageNames,
  }
}

async function verifyYarnLockDidNotChangeAfterYarnInstall(ciCdContext: CiCdContext) {
  const didYarnLockChanged = await execa
    .command(`git diff --quiet yarn.lock`, {
      stdio: 'pipe',
      cwd: ciCdContext.repoPath,
    })
    // the above command returns 1 if the package has changed, 0 if not
    .then(
      () => false,
      () => true,
    )
  if (didYarnLockChanged) {
    console.error(`error: uncommitted changes found in "yarn.lock":`)
    await execa.command(`git diff yarn.lock`, {
      stdio: 'inherit',
      cwd: ciCdContext.repoPath,
    })
    throw new Error(
      'yarn.lock changed after running: "yarn install" in the ci/cd. please run "yarn install" again locally and commit the changes in the yarn.lock file.',
    )
  }
}

async function verifyAbiAndContractTypeGenerations(ciCdContext: CiCdContext) {
  console.log(`generating typescript types from solidity contracts to verify that they already exist in git... `)
  // the types files are expected to be prittifed as well
  const generateTypesCommand = `yarn workspace @coti-cvi/contracts-deploy run regen-types && yarn create-auto-generated-code && yarn workspace @coti-cvi/contracts-deploy export-deployments`
  await execa.command(generateTypesCommand, {
    stdio: 'pipe',
    shell: true,
    cwd: ciCdContext.repoPath,
  })

  const autoGeneratedCodePackagePath = ciCdContext.packages.packages.find(
    p => p.packageJson.name === '@coti-cvi/auto-generated-code',
  )

  if (!autoGeneratedCodePackagePath) {
    throw new Error('@coti-cvi/auto-generated-code package not found')
  }

  const didTypesChangedCommand = `git diff --quiet ${autoGeneratedCodePackagePath.dir}`
  const didTypesChanged = await execa
    .command(didTypesChangedCommand, {
      stdio: 'inherit',
      cwd: ciCdContext.repoPath,
    })
    // the above command returns 1 if the package has changed, 0 if not
    .then(
      () => false,
      () => true,
    )
  if (didTypesChanged) {
    console.error(
      `error: uncommitted changes found in "${autoGeneratedCodePackagePath.dir}" (command: "${didTypesChangedCommand}"): `,
    )
    await execa.command(`git diff ${autoGeneratedCodePackagePath.dir}`, {
      stdio: 'inherit',
      cwd: ciCdContext.repoPath,
    })
    throw new Error(
      `looks like ${autoGeneratedCodePackagePath.packageJson.name} package changed after generating types in the CI/CD. This shouldn't happen. Pls run "${generateTypesCommand}" again locally and commit the changes in the package.`,
    )
  }
  console.log(`verified that the genrated types are in git`)
}

async function verifyNothingChanged(ciCdContext: CiCdContext) {
  const didSomethingChanged = await execa
    .command(`git diff --quiet`, {
      stdio: 'pipe',
      cwd: ciCdContext.repoPath,
    })
    // the above command returns 1 if the package has changed, 0 if not
    .then(
      () => false,
      () => true,
    )

  if (didSomethingChanged) {
    console.error('error: uncommitted changes found in the repo:')
    await execa.command(`git diff`, {
      stdio: 'inherit',
      cwd: ciCdContext.repoPath,
    })
    throw new Error(
      `looks like something (look above) was changed during the CI/CD. This shouldn't happen. Pls check it locally again locally and commit the changes in the package.`,
    )
  }
}

export async function runCi({
  env,
  ciCdCommandArguments,
}: {
  env: Omit<NodeJS.ProcessEnv, 'NODE_ENV'>
  ciCdCommandArguments: CiCdCommandArguments
}): Promise<void> {
  if (ciCdCommandArguments.publishNpmPackages) {
    if (!ciCdCommandArguments.npmRegistryAddress || !ciCdCommandArguments.npmRegistryToken) {
      throw new Error(`npmRegistryAddress and npmRegistryToken are required when publishNpmPackages is true`)
    }
  }
  if (ciCdCommandArguments.k8sNamespaceToDeploy) {
    if (!ciCdCommandArguments.k8sConfigBase64 || !ciCdCommandArguments.k8sNamespaceToDeploy) {
      throw new Error(`k8sConfigBase64 and k8sNamespaceToDeploy are required when deployBackendPackagesToK8s is true`)
    }
  }
  if (ciCdCommandArguments.k8sNamespaceToDeploy) {
    if (!ciCdCommandArguments.k8sConfigBase64 || !ciCdCommandArguments.k8sNamespaceToDeploy) {
      throw new Error(`k8sConfigBase64 and k8sNamespaceToDeploy are required when deployBackendPackagesToK8s is true`)
    }
  }

  const fixedRegistryAddress =
    ciCdCommandArguments.npmRegistryAddress &&
    (ciCdCommandArguments.npmRegistryAddress[ciCdCommandArguments.npmRegistryAddress.length - 1] === '/'
      ? ciCdCommandArguments.npmRegistryAddress.slice(0, -1)
      : ciCdCommandArguments.npmRegistryAddress)

  const npmRegistry = fixedRegistryAddress &&
    ciCdCommandArguments.npmRegistryToken && {
      registryAddress: fixedRegistryAddress,
      token: ciCdCommandArguments.npmRegistryToken,
    }

  const context = await getCiCdContext({ env, ciCdCommandArguments })

  const report = {
    publishToNpm: ciCdCommandArguments.publishNpmPackages,
    deployUiToSurge: ciCdCommandArguments.deployUiPackagesStrategy,
    deployToK8s: ciCdCommandArguments.deployBackendPackagesToK8s,
    context: omit(context, ['packages', 'changedPackages']),
    ciCdCommandArguments,
  }

  console.log('starting to', JSON.stringify(report, null, 2))

  if (context.isPrBuild) {
    await deployAllUiPackagesToSurge({
      context,
      deployUiPackagesStrategy: ciCdCommandArguments.deployUiPackagesStrategy,
      botGithubAccessToken: ciCdCommandArguments.githubAccessToken,
    })
  }

  if (ciCdCommandArguments.runGitDiffVerifications) {
    await verifyNothingChanged(context)

    await verifyYarnLockDidNotChangeAfterYarnInstall(context)

    await verifyAbiAndContractTypeGenerations(context)
  }

  console.log('------------------------')
  console.log('------------------------')
  console.log('------------------------')

  // skipping because we do not use any package outside
  // await publicAllNpmPackagesToNpmRegistry({
  //   context,
  //   publishNpmPackages: ciCdCommandArguments.publishNpmPackages,
  //   npmRegistry,
  // })

  console.log('------------------------')
  console.log('------------------------')
  console.log('------------------------')

  if (
    ciCdCommandArguments.dockerRegistryUsername &&
    ciCdCommandArguments.dockerRegistryToken &&
    ciCdCommandArguments.k8sConfigBase64 &&
    ciCdCommandArguments.k8sNamespaceToDeploy &&
    npmRegistry
  ) {
    await deployAllBackendPackagesToK8s({
      context,
      dockerRegistry: {
        username: ciCdCommandArguments.dockerRegistryUsername,
        token: ciCdCommandArguments.dockerRegistryToken,
      },
      k8sConfigBase64: ciCdCommandArguments.k8sConfigBase64,
      k8sNamespaceToDeploy: ciCdCommandArguments.k8sNamespaceToDeploy,
      deployBackendPackagesToK8s: ciCdCommandArguments.deployBackendPackagesToK8s,
      npmRegistry,
      runDockerBuild: ciCdCommandArguments.runDockerBuild,
    })
  }

  console.log('------------------------')
  console.log('------------------------')
  console.log('------------------------')

  if (context.isMainBuild) {
    await deployAllUiPackagesToSurge({
      context,
      deployUiPackagesStrategy: ciCdCommandArguments.deployUiPackagesStrategy,
      botGithubAccessToken: ciCdCommandArguments.githubAccessToken,
    })
  }

  if (context.isMainBuild && ciCdCommandArguments.keyValueStoreApiKey) {
    // if we are here, the build was successful.
    // save current commit-sha to be main-sha for the next build
    // as a base-branch for the diff
    await axios.post(
      `https://keyvalue.immanuel.co/api/KeyVal/UpdateValue/mitd498g/previous-origin-main-sha/${context.gitHeadSha}`,
    )
  }

  if (ciCdCommandArguments.runGitDiffVerifications) {
    await verifyNothingChanged(context)
  }

  console.log('------------------------')
  console.log('------------------------')
  console.log('------------------------')

  console.log('finished', JSON.stringify(report, null, 2))
}
